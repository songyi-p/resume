[
  {
    "src" : "/images/javascript.png",
    "alt" : "Javascript",
    "desc" : [
      "배열과 객체 메서드를 사용하여 적절하게 데이터를 가공할 수 있습니다.",
      "클로저와 렉시컬 환경에 대한 이해를 바탕으로 함수 로직을 짤 수 있습니다."
    ]
  },
  {
    "src" : "/images/typescript.png",
    "alt" : "Typescript",
    "desc" : [
      "interface와 type에 대한 차이를 이해하고 있습니다.",
      "유틸리티 타입을 사용하여 더 제네릭한 코드를 짤 수 있습니다.",
      "라이브러리의 index.d.ts를 분석하여 타입을 명세할 수 있습니다."
    ]
  },
  {
    "src" : "/images/react.webp",
    "alt" : "React",
    "desc" : [
      "prevState 및 useEffect를 사용해 setState의 비동기 배치 업데이트를 제어할 수 있습니다.",
      "커스텀 훅을 활용해 로직의 재사용성과 코드 통일성을 높일 수 있습니다."
    ]
  },
  {
    "src" : "/images/redux.png",
    "alt" : "Redux",
    "desc" : [
      "FLUX 패턴을 이해하고 이를 적용할 수 있습니다.",
      "store와 reducer를 생성하여 컴포넌트 밖에서 일관성있는 상태 관리를 할 수 있습니다."
    ]
  },
  {
    "src" : "/images/react-query.svg",
    "alt" : "React-query",
    "desc" : [
      "Mutate 시점을 조절하고, query 결과에 따른 데이터 및 에러 처리를 할 수 있습니다.",
      "query-key를 통해 서버 state를 효율적으로 캐싱할 수 있습니다.",
      "useQueryClient를 사용해 전역으로 query를 관리할 수 있습니다."
    ]
  },
  {
    "src" : "/images/next.jpeg",
    "alt" : "Next.js",
    "desc" : [
      "SEO를 위한 SSR의 필요성에 대해 이해하고 있고, vercel을 통해 프로젝트를 배포할 수 있습니다.",
      "next/Image을 활용하여 사이즈 최적화와 lazy-loading으로 웹성능을 향상시킬 수 있습니다."
    ]
  }
]