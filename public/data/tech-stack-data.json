[
  {
    "src" : "/images/javascript.png",
    "alt" : "Javascript",
    "desc" : [
      "배열과 객체 메서드를 사용하여 적절하게 데이터를 가공할 수 있습니다.",
      "실행컨텍스트와 클로저에 대한 이해를 바탕으로 함수 로직을 짤 수 있습니다."
    ]
  },
  {
    "src" : "/images/typescript.png",
    "alt" : "Typescript",
    "desc" : [
      "interface와 type에 대한 차이를 이해하고 있습니다.",
      "React에서 타입스크립트를 적용할 수 있고, 유틸리티 타입을 사용하여 더 제네릭한 코드를 짤 수 있습니다.",
      "라이브러리의 index.d.ts를 분석하여 타입을 명세할 수 있습니다."
    ]
  },
  {
    "src" : "/images/react.webp",
    "alt" : "React",
    "desc" : [
      "setState의 비동기 배치 업데이트를 이해하고 있고, prevState 및 useEffect를 사용해 이를 제어할 수 있습니다.",
      "커스텀 훅을 활용해 로직의 재사용성과 코드 통일성을 높일 수 있습니다."
    ]
  },
  {
    "src" : "/images/redux.png",
    "alt" : "Redux",
    "desc" : ["스토어를 통해 컴포넌트 밖에서 상태관리를 ", "스크립트"]
  },
  {
    "src" : "/images/react-query.svg",
    "alt" : "React-query",
    "desc" : [
      "query-key를 통해 서버 state를 효율적으로 캐싱할 수 있습니다.",
      "제공되는 옵션을 활용해 mutate 시점을 조절하고, query 결과에 따라 데이터 및 에러 처리를 할 수 있습니다.",
      "useQueryClient를 사용해 전역으로 query를 관리할 수 있습니다."
    ]
  },
  {
    "src" : "/images/next.jpeg",
    "alt" : "Next.js",
    "desc" : [
      "타입",
      "vercel를 활용해 배및"
    ]
  }
]